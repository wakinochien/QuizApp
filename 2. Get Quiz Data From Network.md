# QuizApp

Objective: Learn To Get A Quiz Data From Network

Prerequisites
This project is for users who have completed [1. Create Quiz App in RecycleView](https://github.com/wakinochien/QuizApp/blob/recycle_view_quiz_list/1.%20Quiz%20App%20in%20RecycleView.md)

We are going to use third party libraries, Retrofit Library RESTful Quiz web service.

 #### Step 1 : Check build.gradle ####
- Open the project's top-level level build.gradle(Project: QuizApp) file. Notice the repositories listed under the repositories block. You should see two repositories, google(), mavenCentral().

 #### Step 2 : Add Retrofit Library ####
- Open app level build.gradle file, build.gradle, Add these library to this :

     ```
    dependencies {
    …
    // Retrofit
        implementation ("com.squareup.retrofit2:retrofit:2.9.0")
    …
    }
     ```

 #### Step 3 :Support Java 8  ####
 - Add code below to app level build.gradle file
   
     ```
    android {
      ...
    
      compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
      }
     
      kotlinOptions {
        jvmTarget = '1.8'
      }
    }
     ```
 #### Step 4 :Add network folder  ####
- Create a new package called network. (app/src/main/java/com/agmoacademy/quizapp/network)

 #### Step 5 :Add ApiService.kt  ####
- Create a new Kotlin file under the new package network. Name it ApiService.
- Add the following constant for the base URL for the web service.
  
      ```
      private const val BASE_URL = "https://opentdb.com/api.php"
      ```
  
 #### Step 6 : Retrofit creation ####
- Retrofit builder to build and create a Retrofit object. 
  
      ```
       private val retrofit = Retrofit.Builder()
         .baseUrl(BASE_URL)
         .build()
      ```

#### Step 6 : Retrofit creation ####
- Create a interface named ApiService that explains how Retrofit talks to our web server. Here we use the suspend function. So that you can call this method from within a coroutine later 

     ```
    interface ApiService {
    @GET(".")
     suspend fun getQuizList(
            @Query("amount") amount: Int,
            @Query("category") category: Int,
            @Query("difficulty") difficulty: String,
            @Query("type") type: String,
        ): Quiz
    }
     ```

#### Step 6 : Retrofit creation ####
- Now we are going to create object declarations which are used to declare singleton objects. Singleton pattern ensures that one, and only one, instance of an object is created, has one global point of access to that object.
- Initialize the retrofitService variable using the retrofit.create() method with the MarsApiService interface.

     ```
      object QuizApi {
          val retrofitService: ApiService by lazy { retrofit.create(ApiService::class.java) }
      }
     ```

#### Step 7 : QuizViewModel ####
- Create a new package called viewmodel and create the kotlin file name QuizViewModel
- Add the function named it as getQuizList and  launch the coroutine using viewModelScope.launch.

    ```
    private fun getQuizList() {
        viewModelScope.launch {
        }
    }
    ```
- Init the Called getQuizList() method from the retrofitService and store the value to listResult.
- private val _list = MutableLiveData<List<Question>>()

    ```
    private fun getQuizList() {
        viewModelScope.launch {
    	val listResult = QuizApi.retrofitService.getQuizList(
                      amount = 10,
                      category = 18,
                      difficulty = "easy",
                      type = "multiple"
                    )
                    _list.value = listResult.results
        }
    }
    ```

#### Step 8 : Handle network error  ####
- use try catch exception to handle network error and return empty list when error occurs
  
    ```
    private fun getQuizList() {
        viewModelScope.launch {
        try{
    	    val listResult = QuizApi.retrofitService.getQuizList(
                        amount = 10,
                        category = 18,
                        difficulty = "easy",
                        type = "multiple"
                    )
                    _list.value = listResult.results
    	    } catch (e: Exception) {
                    _list.value = listOf()
                }
        }
    }  
    ```

#### Step 9 : Add network permission  ####
- Open manifests/AndroidManifest.xml(app/src/main/AndroidManifest.xml) . 
- Add this line just before the <application> tag:

    ```
    <manifest xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">
    
        <!-- In order for our app to access the Internet, we need to define this permission. -->
        <uses-permission android:name="android.permission.INTERNET" />
    
    …
    </manifest>

    ```

#### Step 10 : Support Json Serialization  ####
- Add moshi library to app level build.gradle and init the moshi by using builder at ApiService file

    ```
    dependencies {
      …
    // Moshi
    implementation ("com.squareup.moshi:moshi-kotlin:1.13.0")
    // Retrofit with Moshi Converter
    implementation ("com.squareup.retrofit2:converter-moshi:2.9.0")
      …
     }
    ```
#### Step 11 : Add KotlinJsonAdapterFactory to ApiService ####
- Use KotlinJsonAdapterFactory to let Retrofit know it can use Moshi to convert the JSON response into Kotlin objects
    ```
    private val moshi = Moshi.Builder()
       .add(KotlinJsonAdapterFactory())
       .build()
    ```

#### Step 12 : Add convertor to Retrofit ####
- Add the convertor to retrofit
    ```
    addConverterFactory(MoshiConverterFactory.create(moshi))
    ```
    
    Final Result:
    ```
    private val retrofit = Retrofit.Builder()
       .addConverterFactory(MoshiConverterFactory.create(moshi))
       .baseUrl(BASE_URL)
       .build()
    ```

#### Step 13 : Using Json annotation mapped to the JSON   ####
- Modify the members in Quiz data class and Question data class to match to the API response
- Use the @Json variable can be mapped to the JSON attribute response_code using @Json(name = "response_code").
    ```
    data class Quiz(
       @Json(name = "response_code")
       val responseCode: Long,
       val results: List<Question>,
    )
    ```

- Same goes to correct_answer and incorrect_answers

    ```  
    data class Question(
    …
       @Json(name = "correct_answer")
        val correctAnswer: String,
    
        @Json(name = "incorrect_answers")
        val incorrectAnswers: List<String>,
    …
    }
    ```

#### Step 14 : Init QuizViewModel in MainActivity  ####
- After complete the livedata setup and data modification to match the API response, now we init the viewmodel at observer 
- private val viewModel: QuizViewModel by viewModels()

#### Step 15 : Create Observer in MainActivity ####
- Create a method called initObserver() and this method is to observe the changes when we connect to API
  ```
   private fun initObserver() {
        viewModel.quizList.observe(this) { list ->
            // Initialize data.
            val myDataset: List<Question> = list

        }
    }
  ```

#### Step 16 : Create Observer in MainActivity ####
- Add toast to indicated the API response is return
   ```
    Toast.makeText(this, "List size = ${list.size}", Toast.LENGTH_SHORT).show()
   ```

Final Result:
    ```
   private fun initObserver() {
        viewModel.quizList.observe(this) { list ->
            // Initialize data.
            val myDataset: List<Question> = list
            Toast.makeText(this, "List size = ${list.size}", Toast.LENGTH_SHORT).show()
        }
    }
    ```

#### Step 17 : Trigger API in MainActivity ####
- Create getData function to trigger API in MainActivity
  ```
   private fun getData() {
        viewModel.getQuizList()
    }
  ```

#### Step 18 : Modification on QuizAdapter ####
- Now is the step to modify the adapter to accept data from API, Change the list to mutable list in QuizAdapter 
  ```
  private val dataset: MutableList<Question>,
  ```
  

- Add clear method  in QuizAdapter 
  ```
   fun clear() {
        dataset.clear()
    }
  ```

- Add addAll method in QuizAdapter 
  ```
  fun addAll(list: List<Question>) {
          dataset.addAll(list)
          notifyDataSetChanged()
      }
  ```

#### Step 19 : Pass empty list as initial default value ####
- Change the list to empty list at the beginning 
  ```
  adapter = QuizAdapter(this, mutableListOf())
  ```


#### Step 20 : Pass empty list as initial default value ####
- Add the data to adapter. Clear the data before add list to it in initObserver method 
  ```
   private fun initObserver() {
        viewModel.quizList.observe(this) { list ->
            // Initialize data.
            val myDataset: List<Question> = list

            adapter?.clear()
            adapter?.addAll(myDataset)
        }
    }
  ```

#### Step 21 : Finish ####
- After the modification can run the app 








